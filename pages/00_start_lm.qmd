---
title: "Understanding a linear model"
date: "last-modified"
echo: true 
warning: false 
message: false
---

> How to compute ANOVA for a randomized complete block design (RCBD) by hand, verify with `lm()`, and extract genotype means and pairwise comparisons with **emmeans**.


## 1) Setup & data

Clewer and Scarisbrick (2001) present a yield trial (t/ha) conducted using a randomized complete block design. The design included three blocks and four cultivars, resulting in 12 experimental plots.

```{r}
library(tidyverse)
library(emmeans)
library(gt)

# Read and coerce factors
data <- read.csv("../data/example_1.csv") |>
  mutate(gen = as.factor(gen), block = as.factor(block))
head(data)
str(data)
```

### Quick visualization

```{r}
#| fig-cap: "Yield by genotype colored by block."
#| fig-width: 7
#| fig-height: 4

data |>
  ggplot(aes(x = gen, y = yield, color = block)) +
  geom_point(size = 3) +
  theme_classic(base_size = 15)
```

### Descriptive means

```{r}
# Mean by genotype
by_gen <- data |>
  group_by(gen) |>
  summarise(mean = mean(yield), .groups = "drop")
by_gen |> gt()
# Mean by block
by_blk <- data |>
  group_by(block) |>
  summarise(mean = mean(yield), .groups = "drop")
by_blk |> gt()
# Overall mean
overall <- data |>
  summarise(mean = mean(yield))
overall
```

## 2) Linear model building blocks

We will progressively build the RCBD model using `model.frame()` and `model.matrix()` to see the design matrices explicitly, then solve normal equations. We use:

-   $y$: response vector (yield)
-   $X$: model matrix
-   $\hat\beta = (X^\top X)^{-1} X^\top y$
-   Fitted values $\hat y = X\hat\beta$
-   Errors $e = y - \hat y$
-   Sum of squared errors $\text{SSE} = e^\top e$

Let `n = 12` observations, `n_blks = 3` blocks, `n_gens = 4` genotypes.

```{r}
n <- 12
n_blks <- 3
n_gens <- 4
```

### 2.1 Intercept-only model (overall mean)

```{r}
ff <- yield ~ 1
m <- model.frame(ff, data)
X <- model.matrix(ff, m)
y <- matrix(data$yield)

# Normal equations components
Xty <- t(X) %*% y
XtX <- t(X) %*% X
rank_X <- qr(XtX)$rank
XtX_inv <- solve(XtX)

beta_mu <- XtX_inv %*% Xty # overall mean (mu)
y_hat <- X %*% beta_mu
errors <- y - y_hat
SSE_mu <- t(errors) %*% errors
SSE_mu <- as.numeric(SSE_mu)

list(rank = rank_X, beta_mu = drop(beta_mu), SSE_mu = SSE_mu)
```

### 2.2 Add blocks

```{r}
ff <- yield ~ -1 + block
m <- model.frame(ff, data)
X <- model.matrix(ff, m)
y <- matrix(data$yield)

Xty <- t(X) %*% y
XtX <- t(X) %*% X
rank_X <- qr(XtX)$rank
XtX_inv <- solve(XtX)

beta_blk <- XtX_inv %*% Xty
SSE_blk <- t(y - X %*% beta_blk) %*% (y - X %*% beta_blk)
SSE_blk <- as.numeric(SSE_blk)

list(rank = rank_X, beta_blk = drop(beta_blk), SSE_blk = SSE_blk)
```

### 2.3 Genotype main effects (no intercept)

We fit `yield ~ -1 + gen` to obtain cell means directly for genotypes.

```{r}
ff <- yield ~ -1 + gen
m <- model.frame(ff, data)
X <- model.matrix(ff, m)
y <- matrix(data$yield)

Xty <- t(X) %*% y
XtX <- t(X) %*% X
rank_X <- qr(XtX)$rank
XtX_inv <- solve(XtX)

beta_gen <- XtX_inv %*% Xty
SSE_gen <- t(y - X %*% beta_gen) %*% (y - X %*% beta_gen)
SSE_gen <- as.numeric(SSE_gen)

m2 <- list(rank = rank_X, beta_gen = drop(beta_gen), SSE_gen = SSE_gen)
```

### 2.4 Full model: intercept + blocks + genotypes

```{r}
ff <- yield ~ 1 + block + gen
m <- model.frame(ff, data)
X <- model.matrix(ff, m)
y <- matrix(data$yield)

Xty <- t(X) %*% y
XtX <- t(X) %*% X
rank_X <- qr(XtX)$rank
XtX_inv <- solve(XtX)

beta <- XtX_inv %*% Xty
SSE <- t(y - X %*% beta) %*% (y - X %*% beta)
SSE <- as.numeric(SSE)

list(rank = rank_X, betas = drop(beta), SSE = SSE)
```

## 3) Reduction-in-SS and ANOVA table

The partial sums of squares for `block` and `gen` can be obtained as reductions from the intercept-only model:

```{r}
SSE_mu # intercept-only
SSE_mu - SSE_blk # SS for blocks
SSE_mu - SSE_gen # SS for genotypes
SSE # residual SS from full model
```

We now assemble an ANOVA table. Residual df is `n - p`, where `p` is the number of coefficients in the full model.

```{r}
# Sigma^2 estimate using the full model (p = length(beta))
sigma_2 <- SSE / (n - length(beta))
sigma_2

anova_dt <- data.frame(
  Source = c("block", "gen", "residuals"),
  Df     = c(n_blks - 1, n_gens - 1, n - length(beta)),
  SSq    = c(SSE_mu - SSE_blk, SSE_mu - SSE_gen, SSE)
) |>
  mutate(
    MSq = SSq / Df,
    F.value = MSq / MSq[3],
    `Pr(>F)` = pf(q = F.value, df1 = Df, df2 = Df[3], lower.tail = FALSE),
    F.value = ifelse(Source == "residuals", NA, F.value),
    `Pr(>F)` = ifelse(Source == "residuals", NA, `Pr(>F)`)
  )

anova_dt
```

::: {.callout-note} 
**Why does this work?** In fixed-effects ANOVA, Type-I SS for adding a factor equals the reduction in SSE between nested models. Here we use the intercept-only model as the baseline; adding `block` or `gen` reduces SSE by their respective SS. 
:::

## 4) Verify with `lm()`

```{r}
mod <- lm(yield ~ 1 + block + gen, data = data)
summary(mod)
coef(mod)
anova(mod)
round(vcov(mod), 5)

# Check that (X'X)^{-1} * sigma^2 matches vcov
round(XtX_inv * sigma_2, 5)
```

## 5) Interpreting coefficients under treatment coding

With `block` and `gen` as factors and an intercept present, R uses treatment (reference-cell) coding by default. The printed `beta` therefore contains:

-   `beta[1]`: the intercept (mean for the reference levels `block1` and `gen1` reference)
-   `beta[2:3]`: effects for non-reference blocks
-   `beta[4:6]`: effects for non-reference genotypes

You can reconstruct **overall mean**, **genotype cell means**, and **block means** as follows.

```{r}
# Number of coefficients in full model
n_coef <- length(beta)

# Overall mean reconstructed from coefficients
mu_recon <- beta[1] + sum(c(0, beta[2:3])) / n_blks + sum(c(0, beta[4:6])) / n_gens
mu_recon

# Compare with the intercept-only estimate
beta_mu
```

### 5.1 Genotype means including the missing (reference) level

```{r}
# beta currently has: (Intercept), block2, block3, gen2, gen3, gen4
# Create a named vector for gen effects including the reference level set to 0
print(beta)
gens <- c("geng1" = 0, beta[4:6, ])
# Add back the intercept and average block effect
gens <- beta[1] + sum(beta[2:3]) / n_blks + gens
gens
```

### 5.2 Block means including the missing (reference) level

```{r}
print(beta)
blks <- c("block1" = 0, beta[2:3, ])
blks <- beta[1] + sum(beta[4:6]) / n_gens + blks
blks
```

## 6) Estimated marginal means and pairwise comparisons

`emmeans` provides adjusted means (marginal over the other factors) and convenient contrasts.

```{r}
# Genotype adjusted means
emm_gen <- emmeans(mod, ~gen)
emm_gen

# Standard errors of genotype via (X'X)^{-1}
sqrt(diag(XtX_inv)[4:6] * sigma_2) 

# Pairwise genotype comparisons
pairs(emm_gen)

# For a quick hand-check of a simple pairwise SE when balanced:
sqrt(sigma_2 / 3 + sigma_2 / 3)
```

::: {.callout-important} 
Notice that the standard errors via $(X' X)^{-1}\sigma^2$ are different to the ones return by `emmeans`. Interestingly those from $(X' X)^{-1}\sigma^2$ look exactly like the pairwise genotype comparison Standard Errors. Why? We will see why in the next article.
:::
